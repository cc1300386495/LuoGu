# 康托展开

康托展开用于完成**全排列（从小到大）到自然数**的双边映射。

### 举例说明



现有集合{1，2，3，4}，请给出2143是集合的全排列中第几大数字。

- 首先可以认为首位小于2的一定小于2143。数量为：len{1} * 3！
- 同理，当首位为2时，只要第2位小于1即可（不存在）。数量为：len(0) * 2！
- 继续递推，第3位小于4时即可，但注意{2，1}已经在前2位出现了，所以数量为：len{3} * 1!
- 第4位同理，数量为len{} * 0!

所有数量求和，便找到了全排列当中有多少组合比2143大。



故而我们得出了公式：

设集合的长度为$n$,所求排列为$s$, $a[i]$表示小于$s[i]$且未在$s[:i]$中出现的数的个数。

那么，$s$在全排列中的次序为：

$a[1] * (n-1)! + a[2] * (n-2!) + ···+a[n] * (n-n)!$



#### 逆展开

逆展开就是给出全排列中第x大的组合。

假设我们想要找到{1,2,3,4,5}中第61大的组合。

那么

- 第一位：61/ 4！ 结果为 2 余数为13。所以比第1位小且未出现的数字应该有2个，故第1位取3
- 第二位：13/3！ 结果为2，余数为1。所以比第2位小且未出现的数字应该有2个，故第2位取4
- 第三位：1/2！ 结果为0，余数为1。所以比第3位小且未出现的数字应该有0个，故第3位取1
- 第四位:   1 / 1!  结果为1，余数为0.所以比第3位小且未出现的数字应该有1个，故第3位取5
- 第五位就取剩下的那个即可。

所以第61大的在一个为34152



**代码实现与相关题目请看P1088.py**